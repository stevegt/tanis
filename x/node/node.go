package node

import (
	"sync"

	. "github.com/stevegt/goadapt"

	_ "net/http/pprof"
)

// Topic is a pub/sub topic that fans out single values to multiple
// subscribers.
type Topic struct {
	// Subscribers is a slice of channels which will receive values
	// published to the topic.
	Subscribers []chan float64
	// Publish is a channel which will receive Values to be published
	// to the topic.
	Publish chan float64
}

// NewTopic creates a new Topic with the given name.
func NewTopic() (t *Topic) {
	t = &Topic{
		Subscribers: make([]chan float64, 0),
		Publish:     make(chan float64, 10),
	}
	go func() {
		defer func() {
			// notify subscribers on exit
			for _, subscriber := range t.Subscribers {
				close(subscriber)
			}
		}()

		for {
			// wait for a value to be published
			value, ok := <-t.Publish
			if !ok {
				// channel is closed
				return
			}
			// send the value to all subscribers
			for _, subscriber := range t.Subscribers {
				subscriber <- value
			}
		}
	}()
	return
}

// Subscribe returns a channel which will receive values published to
// the topic.
func (t *Topic) Subscribe() (c chan float64) {
	c = make(chan float64, 10)
	t.Subscribers = append(t.Subscribers, c)
	return
}

// Aggregator is a fan-in -- it takes several input topics and publishes a single output
// slice.  The output slice is published each time all input topics
// have received a value.
type Aggregator struct {
	Input       []*Topic
	Subscribers []chan []float64
}

// NewAggregator creates a new Aggregator with the given input topics.
func NewAggregator(inputTopics []*Topic) (a *Aggregator) {
	a = &Aggregator{
		Input:       inputTopics,
		Subscribers: make([]chan []float64, 0),
	}

	// subscribe to the input topics
	var inputChans []chan float64
	for _, inputTopic := range a.Input {
		inputChans = append(inputChans, inputTopic.Subscribe())
	}

	go func() {
		defer func() {
			// notify subscribers on exit
			for _, subscriber := range a.Subscribers {
				close(subscriber)
			}
		}()

		// read from all input channels until they are closed
		closedCount := 0
		for {
			// read from all input channels. we need to read from each
			// in a separate goroutine to avoid blocking and to handle
			// the case where one or more channels are closed.
			values := make([]float64, len(inputChans))
			wg := &sync.WaitGroup{}
			for i := range inputChans {
				wg.Add(1)
				// start goroutine for topic i
				go func(i int) {
					defer wg.Done()
					// read one value from topic i
					input, ok := <-inputChans[i]
					if ok {
						// channel is open
						values[i] = input
						return
					}
					// channel is closed
					closedCount++
				}(i)
			}
			// wait for all input channels to be read
			wg.Wait()
			if closedCount == len(inputChans) {
				return
			}

			// send the values slice to all subscribers
			for _, subscriber := range a.Subscribers {
				subscriber <- values
			}
		}
	}()
	return
}

// Subscribe returns a channel which will receive each slice of values
// published by the aggregator.
func (a *Aggregator) Subscribe() (c chan []float64) {
	c = make(chan []float64, 10)
	a.Subscribers = append(a.Subscribers, c)
	return
}

// Function is a function which takes a slice of float64 arguments and
// returns a float64 result.  The number of arguments is specified by
// ArgCount.
type Function struct {
	Fn       func(...float64) float64
	ArgCount int
}

// Node is a node in a dataflow graph.  It has a Function which
// calculates a result from a slice of input values.
type Node struct {
	Id       uint64
	Function Function
	Input    *Aggregator
	Output   *Topic
}

// NewNode creates a new node with the given Function.
// An output is generated each time a value slice is generated by the
// input aggregator.  If the input aggregator is nil, the node has no
// input and the output is generated immediately by the node's
// Function.
func NewNode(id uint64, fn Function, input *Aggregator, output *Topic) (n *Node) {

	n = &Node{
		Id:       id,
		Function: fn,
		Input:    input,
		Output:   output,
	}

	var inputChan chan []float64
	if n.Input != nil {
		// subscribe to the input topic
		c := n.Input.Subscribe()
		inputChan = c
	}

	outputChan := n.Output.Publish

	go func() {
		defer func() {
			// notify output topic on exit
			close(outputChan)
		}()

		for {
			var inputs []float64
			if inputChan != nil {
				// read a value slice from the input aggregator
				in, ok := <-inputChan
				inputs = in
				if !ok {
					// channel is closed
					return
				}
			}

			Assert(len(inputs) == n.Function.ArgCount, "Node %d: expected %d inputs, got %d", n.Id, n.Function.ArgCount, len(inputs))

			// calculate the result
			result := n.Function.Fn(inputs...)
			// send the result to the output topic
			outputChan <- result
		}
	}()
	return
}

// Log collects messages in a channel and writes them to stdout.
type Log struct {
	MsgChan chan string
}

// NewLog creates a new Log.
func NewLog() (l *Log) {
	l = &Log{
		MsgChan: make(chan string, 100),
	}
	go func() {
		for msg := range l.MsgChan {
			Pl(msg)
		}
	}()
	return
}

// I logs a message.
func I(args ...interface{}) {
	msg := FormatArgs(args...)
	logger.MsgChan <- msg
}

var logger *Log
